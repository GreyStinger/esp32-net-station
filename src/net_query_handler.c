#include "net_query_handler.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// Private method that adds a query pair to the linked list
// 
// If no linked list exists create a new one
// Memory is allocated with malloc and thus you have
// to call `free_esp_query_list` with the head of the list
// when you are done with it
static esp_query_pair_t * add_query_pair(esp_query_pair_t *last_pair, char *key, char *val)
{
	esp_query_pair_t *query_pair;
	
	query_pair = (esp_query_pair_t *) malloc(sizeof(esp_query_pair_t));
	if (query_pair != NULL)
	{
		query_pair->key = key;
		query_pair->val = val;
		query_pair->next = last_pair;
	}

	return query_pair;
}

// Deallocates entire linked esp_query_pair_t list
//
// Takes head of linked list generated by `add_query_pair`
// and deallocates the whole linked list from memory
void free_esp_query_list(esp_query_pair_t * query_list)
{
	if (query_list->next != NULL) free_esp_query_list(query_list->next);
	free(query_list->next);
	free(query_list->key);
	free(query_list->val);
}

// Gets and returns the a ponter to the value for the corresponding key
//
// Searches throught the linked list looking for the given key
// and returns the corresponding value, it isn't efficient, but
// it's currently not a huge performance loss
char *fetch_query_val(esp_query_pair_t *query_list, char *key)
{
	esp_query_pair_t *current_pair;
	signed int is_current = -1;
	for (current_pair = query_list; current_pair != NULL; current_pair = current_pair->next)
	{
		is_current = strcmp(key, current_pair->key);
		if (!is_current) return current_pair->val;
	}
	return NULL;
}

// Extracts and handles a query from a url
//
// Url as parameter
// Returns null if there is no query
// Else returns a pointer to the first key_val pair
esp_query_pair_t* handle_esp_query(const char* url) {
    const char* unhandled_query_section = strchr(url, '?');
    if (unhandled_query_section == NULL) {
        return NULL;
    }

    esp_query_pair_t* query_pair_list = NULL;
    const char* divider;
    unsigned int key_len, val_len;
    const char* key_start;
    const char* val_start;

    while (*unhandled_query_section != '\0') {
        unhandled_query_section++; // Move past '?', '&', or '\0'
        key_start = unhandled_query_section;

        divider = strchr(key_start, '=');
        if (divider == NULL) {
            break;
        }

        key_len = (unsigned int)(divider - key_start);
        val_start = divider + 1;

        divider = strpbrk(val_start, "&\0");
        if (divider == NULL) {
            val_len = (unsigned int)(strlen(val_start));
        } else {
            val_len = (unsigned int)(divider - val_start);
        }

        char* key = (char*)malloc(sizeof(char) * (key_len + 1));
        char* val = (char*)malloc(sizeof(char) * (val_len + 1));

        if (key == NULL || val == NULL) {
            // Handle memory allocation error
            free(key);
            free(val);
            // Free any previously allocated memory in query_pair_list
            // and return appropriate error code or NULL
            break;
        }

        memcpy(key, key_start, key_len);
        key[key_len] = '\0';
        memcpy(val, val_start, val_len);
        val[val_len] = '\0';

        query_pair_list = add_query_pair(query_pair_list, key, val);

        unhandled_query_section = divider;
    }

    return query_pair_list;
}
